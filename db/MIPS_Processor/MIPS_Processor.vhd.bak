library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

-- =========================================================================
-- MIPS_Processor.vhd
-- Este é o componente top-level para o processador MIPS de 32 bits
-- de ciclo único, integrando a ULA de Ponto Flutuante do FloPoCo.
-- (Conforme a Parte 1 do projeto de AOC)
-- =========================================================================
entity MIPS_Processor is
    port (
        Clk : in  std_logic;
        Rst : in  std_logic
    );
end entity MIPS_Processor;

architecture Structural of MIPS_Processor is

    -- =========================================================================
    -- 1. DECLARAÇÃO DOS COMPONENTES (Todos os blocos que construímos)
    -- =========================================================================

    component Program_Counter
        port (
            Clk         : in  std_logic;
            Rst         : in  std_logic;
            Branch_Addr : in  std_logic_vector(31 downto 0);
            PC_Sel      : in  std_logic; 
            PC_Out      : out std_logic_vector(31 downto 0)
        );
    end component;

    component Instruction_Memory
        port (
            Address     : in  std_logic_vector(31 downto 0);
            Instruction : out std_logic_vector(31 downto 0)
        );
    end component;

    component Control_Unit
        port (
            Opcode      : in  std_logic_vector(5 downto 0);
            Funct       : in  std_logic_vector(5 downto 0);
            RegWrite    : out std_logic;
            FP_RegWrite : out std_logic;
            RegDst      : out std_logic;
            Branch      : out std_logic;
            Jump        : out std_logic;
            MemWrite    : out std_logic;
            MemRead     : out std_logic;
            ALUSrc      : out std_logic;
            ALU_Sel     : out std_logic_vector(3 downto 0);
            FP_Op_Sel   : out std_logic;
            WriteBack_Sel : out std_logic_vector(1 downto 0) 
        );
    end component;

    component Integer_Register_File -- (Assumindo o nome do seu arquivo)
        port (
            Clk         : in  std_logic;
            Rst         : in  std_logic;
            Write_Enable: in  std_logic;
            Read_Addr_1 : in  std_logic_vector(4 downto 0);
            Read_Addr_2 : in  std_logic_vector(4 downto 0);
            Data_Out_1  : out std_logic_vector(31 downto 0);
            Data_Out_2  : out std_logic_vector(31 downto 0);
            Write_Addr  : in  std_logic_vector(4 downto 0);
            Data_In     : in  std_logic_vector(31 downto 0)
        );
    end component;

    component FP_Register_File
        port (
            Clk         : in  std_logic;
            Rst         : in  std_logic;
            Write_Enable: in  std_logic;
            Read_Addr_1 : in  std_logic_vector(4 downto 0);
            Read_Addr_2 : in  std_logic_vector(4 downto 0);
            Data_Out_1  : out std_logic_vector(31 downto 0);
            Data_Out_2  : out std_logic_vector(31 downto 0);
            Write_Addr  : in  std_logic_vector(4 downto 0);
            Data_In     : in  std_logic_vector(31 downto 0)
        );
    end component;

    component Integer_ALU
        port (
            A       : in  std_logic_vector(31 downto 0);
            B       : in  std_logic_vector(31 downto 0);
            ALU_Sel : in  std_logic_vector(3 downto 0);
            R       : out std_logic_vector(31 downto 0);
            Zero    : out std_logic
        );
    end component;

    component Data_Memory
        port (
            Clk         : in  std_logic;
            MemWrite    : in  std_logic;
            MemRead     : in  std_logic;
            Address     : in  std_logic_vector(31 downto 0);
            DataIn      : in  std_logic_vector(31 downto 0);
            DataOut     : out std_logic_vector(31 downto 0)
        );
    end component;

    component FP_ALU_Wrapper
        port (
            X_in    : in  std_logic_vector(31 downto 0);
            Y_in    : in  std_logic_vector(31 downto 0);
            Op_sel  : in  std_logic; 
            R_out   : out std_logic_vector(31 downto 0)
        );
    end component;

    -- =========================================================================
    -- 2. SINAIS (Os "fios" que conectam os componentes)
    -- =========================================================================

    -- Sinais de Controle (Saídas da Control_Unit)
    signal s_RegWrite    : std_logic;
    signal s_FP_RegWrite : std_logic;
    signal s_RegDst      : std_logic;
    signal s_Branch      : std_logic;
    signal s_Jump        : std_logic;
    signal s_MemWrite    : std_logic;
    signal s_MemRead     : std_logic;
    signal s_ALUSrc      : std_logic;
    signal s_ALU_Sel     : std_logic_vector(3 downto 0);
    signal s_FP_Op_Sel   : std_logic;
    signal s_WriteBack_Sel : std_logic_vector(1 downto 0);

    -- Sinais do Datapath (Fios principais)
    signal s_PC_Addr          : std_logic_vector(31 downto 0);
    signal s_PC_Plus_4        : std_logic_vector(31 downto 0);
    signal s_Instruction      : std_logic_vector(31 downto 0);
    signal s_Extended_Immediate : std_logic_vector(31 downto 0);
    signal s_Branch_Target_Addr : std_logic_vector(31 downto 0);
    signal s_Jump_Target_Addr   : std_logic_vector(31 downto 0);
    signal s_Next_PC_Addr_Mux   : std_logic_vector(31 downto 0);
    signal s_PC_Load_Enable   : std_logic;

    -- Sinais dos Bancos de Registradores
    signal s_Int_Read_Data_1    : std_logic_vector(31 downto 0);
    signal s_Int_Read_Data_2    : std_logic_vector(31 downto 0);
    signal s_FP_Read_Data_1     : std_logic_vector(31 downto 0);
    signal s_FP_Read_Data_2     : std_logic_vector(31 downto 0);
    signal s_Int_Write_Addr     : std_logic_vector(4 downto 0);
    signal s_FP_Write_Addr      : std_logic_vector(4 downto 0);
    signal s_Write_Back_Data    : std_logic_vector(31 downto 0);

    -- Sinais das ALUs
    signal s_ALU_Input_B        : std_logic_vector(31 downto 0);
    signal s_Int_ALU_Result     : std_logic_vector(31 downto 0);
    signal s_Int_ALU_Zero       : std_logic;
    signal s_FP_ALU_Result      : std_logic_vector(31 downto 0);

    -- Sinais da Memória
    signal s_Memory_Read_Data   : std_logic_vector(31 downto 0);

begin

    -- =========================================================================
    -- 3. LÓGICA DO DATAPATH (MUXes, Extensores de Sinal, etc.)
    -- =========================================================================

    -- --- Lógica de Decodificação e Extensão de Sinal ---
    
    -- Extensor de sinal de 16-bits (imediato) para 32-bits
    s_Extended_Immediate <= std_logic_vector(resize(signed(s_Instruction(15 downto 0)), 32));
    
    -- MUX de seleção do registrador de escrita (RegDst)
    -- '0' = rt (Instr[20-16]), '1' = rd (Instr[15-11])
    -- Usado por AMBOS os bancos de registradores
    s_Int_Write_Addr <= s_Instruction(20 downto 16) when s_RegDst = '0' else s_Instruction(15 downto 11);
    s_FP_Write_Addr  <= s_Instruction(20 downto 16) when s_RegDst = '0' else s_Instruction(15 downto 11);

    -- --- Lógica da ALU de Inteiros ---
    
    -- MUX de seleção da 2ª entrada da ALU de inteiros (ALUSrc)
    -- '0' = Registrador (Read_Data_2), '1' = Imediato (Sign-Extended)
    s_ALU_Input_B <= s_Int_Read_Data_2 when s_ALUSrc = '0' else s_Extended_Immediate;
    
    -- --- Lógica de "Write Back" (Resultado Final) ---

    -- MUX de seleção do dado que será escrito de volta no registrador
    with s_WriteBack_Sel select
        s_Write_Back_Data <= s_Int_ALU_Result    when "00", -- Resultado da ALU de Inteiros
                             s_Memory_Read_Data  when "01", -- Dado da Memória (lw ou l.s)
                             s_FP_ALU_Result     when "10", -- Resultado da ALU de Ponto Flutuante
                             (others => 'X')     when others;
                             
    -- --- Lógica de Atualização do PC (Desvios) ---
    
    -- Calcula PC + 4
    s_PC_Plus_4 <= std_logic_vector(signed(s_PC_Addr) + 4);
    
    -- Calcula o endereço de desvio (Branch Target)
    s_Branch_Target_Addr <= std_logic_vector(signed(s_PC_Plus_4) + signed(s_Extended_Immediate(29 downto 0) & "00"));
    
    -- Calcula o endereço de pulo (Jump Target)
    s_Jump_Target_Addr <= s_PC_Plus_4(31 downto 28) & s_Instruction(25 downto 0) & "00";
    
    -- MUX que escolhe o endereço de desvio (Branch ou Jump)
    s_Next_PC_Addr_Mux <= s_Jump_Target_Addr when s_Jump = '1' else s_Branch_Target_Addr;
    
    -- Habilita o carregamento do PC (PC_Sel) se for Branch E Zero, OU se for Jump
    s_PC_Load_Enable <= (s_Branch and s_Int_ALU_Zero) or s_Jump;

    -- =========================================================================
    -- 4. INSTÂNCIA DOS COMPONENTES (Conectando os fios)
    -- =========================================================================

    -- --- Estágio 1: IF (Instruction Fetch) ---
    
    u_PC: Program_Counter
        port map (
            Clk         => Clk,
            Rst         => Rst,
            Branch_Addr => s_Next_PC_Addr_Mux,
            PC_Sel      => s_PC_Load_Enable,
            PC_Out      => s_PC_Addr
        );

    u_IMem: Instruction_Memory
        port map (
            Address     => s_PC_Addr,
            Instruction => s_Instruction
        );
        
    -- --- Estágio 2: ID (Instruction Decode & Register Fetch) ---
    
    u_Ctrl: Control_Unit
        port map (
            Opcode        => s_Instruction(31 downto 26),
            Funct         => s_Instruction(5 downto 0),
            RegWrite      => s_RegWrite,
            FP_RegWrite   => s_FP_RegWrite,
            RegDst        => s_RegDst,
            Branch        => s_Branch,
            Jump          => s_Jump,
            MemWrite      => s_MemWrite,
            MemRead       => s_MemRead,
            ALUSrc        => s_ALUSrc,
            ALU_Sel       => s_ALU_Sel,
            FP_Op_Sel     => s_FP_Op_Sel,
            WriteBack_Sel => s_WriteBack_Sel
        );

    u_Int_Reg_File: Integer_Register_File
        port map (
            Clk          => Clk,
            Rst          => Rst,
            Write_Enable => s_RegWrite, -- Controlado pela Control_Unit
            Read_Addr_1  => s_Instruction(25 downto 21), -- rs
            Read_Addr_2  => s_Instruction(20 downto 16), -- rt
            Data_Out_1   => s_Int_Read_Data_1,
            Data_Out_2   => s_Int_Read_Data_2,
            Write_Addr   => s_Int_Write_Addr, -- Saída do MUX RegDst
            Data_In      => s_Write_Back_Data -- Saída do MUX WriteBack
        );
        
    u_FP_Reg_File: FP_Register_File
        port map (
            Clk          => Clk,
            Rst          => Rst,
            Write_Enable => s_FP_RegWrite, -- Controlado pela Control_Unit
            Read_Addr_1  => s_Instruction(25 downto 21), -- fs
            Read_Addr_2  => s_Instruction(20 downto 16), -- ft
            Data_Out_1   => s_FP_Read_Data_1,
            Data_Out_2   => s_FP_Read_Data_2,
            Write_Addr   => s_FP_Write_Addr, -- Saída do MUX RegDst
            Data_In      => s_Write_Back_Data -- Saída do MUX WriteBack
        );

    -- --- Estágio 3: EX (Execute) ---
    
    u_Int_ALU: Integer_ALU
        port map (
            A       => s_Int_Read_Data_1, -- Dado do Reg[rs]
            B       => s_ALU_Input_B,     -- Dado do MUX ALUSrc
            ALU_Sel => s_ALU_Sel,
            R       => s_Int_ALU_Result,
            Zero    => s_Int_ALU_Zero
        );

    u_FP_ALU: FP_ALU_Wrapper
        port map (
            X_in    => s_FP_Read_Data_1, -- Dado do Reg[fs]
            Y_in    => s_FP_Read_Data_2, -- Dado do Reg[ft]
            Op_sel  => s_FP_Op_Sel,
            R_out   => s_FP_ALU_Result
        );

    -- --- Estágio 4: MEM (Memory Access) ---
    
    u_DMem: Data_Memory
        port map (
            Clk         => Clk,
            MemWrite    => s_MemWrite,
            MemRead     => s_MemRead,
            Address     => s_Int_ALU_Result,  -- Endereço calculado pela ALU
            DataIn      => s_Int_Read_Data_2, -- Dado a escrever (sw)
            DataOut     => s_Memory_Read_Data -- Dado lido (lw/l.s)
        );

    -- --- Estágio 5: WB (Write Back) ---
    -- (A lógica de Write Back é composta pelos MUXes na Seção 3
    --  e pela conexão 'Data_In' nos Bancos de Registradores na Seção 4)

end architecture Structural;